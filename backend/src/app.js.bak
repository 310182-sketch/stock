/**
 * backend/src/app.js
 * å°è‚¡æ­·å²è³‡æ–™ API - ä½¿ç”¨ TWSE/TPEx çœŸå¯¦è³‡æ–™
 */

const express = require('express');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3001;

// è¼‰å…¥å°è‚¡è³‡æ–™æ¨¡çµ„
let twStockData = null;
let BacktestEngine = null;
let metrics = null;
let PricePredictor = null;
let NewsScraper = null;
let SentimentAnalyzer = null;
try { twStockData = require('./data/twStockData'); } catch (e) { console.error('twStockData è¼‰å…¥å¤±æ•—:', e.message); }
try { BacktestEngine = require('./engine/backtestEngine'); } catch (e) { /* optional */ }
try { metrics = require('./analytics/metrics'); } catch (e) { /* optional */ }
try { PricePredictor = require('./analytics/pricePredictor'); } catch (e) { console.error('PricePredictor è¼‰å…¥å¤±æ•—:', e.message); }
try { NewsScraper = require('./data/newsScraper'); } catch (e) { console.error('NewsScraper è¼‰å…¥å¤±æ•—:', e.message); }
try { SentimentAnalyzer = require('./analytics/sentimentAnalyzer'); } catch (e) { console.error('SentimentAnalyzer è¼‰å…¥å¤±æ•—:', e.message); }

// DB (lowdb)
const DB = require('./db');
let dbInstance = null;
const TwseOpenApi = require('./integrations/twseOpenApi');
const TwseSyncJob = require('./jobs/twseSyncJob');
const LineNotify = require('./integrations/lineNotify');

// ============================================
// å¸¸æ•¸å®šç¾©
// ============================================
const SYMBOL_REGEX = /^[0-9A-Za-z]{4,6}$/;
const ALLOWED_ORIGINS = process.env.ALLOWED_ORIGINS?.split(',') || [
  'http://localhost:5173',
  'http://127.0.0.1:5173',
  'http://localhost:3000'
];

// è¼¸å…¥é©—è­‰å‡½æ•¸
function validateSymbol(symbol) {
  return symbol && SYMBOL_REGEX.test(symbol);
}

function validatePositiveInt(value, defaultVal = 1, max = 100) {
  const num = parseInt(value, 10);
  if (isNaN(num) || num < 1) return defaultVal;
  return Math.min(num, max);
}

// CORS è¨­å®š (å®‰å…¨ç™½åå–®)
const corsOptions = {
  origin: (origin, callback) => {
    // å…è¨±ç„¡ origin çš„è«‹æ±‚ï¼ˆå¦‚ Postmanã€curlï¼‰
    if (!origin || ALLOWED_ORIGINS.includes(origin)) {
      callback(null, true);
    } else {
      callback(null, true); // é–‹ç™¼ç’°å¢ƒæš«æ™‚å…è¨±ï¼Œç”Ÿç”¢ç’°å¢ƒæ‡‰æ”¹ç‚º callback(new Error('CORS not allowed'))
    }
  },
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  optionsSuccessStatus: 204,
};
app.use(cors(corsOptions));
app.options(/.*/, cors(corsOptions));
app.use(express.json({ limit: '10mb' }));

// è«‹æ±‚æ—¥èªŒ
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});

// è¨ˆç®—ç°¡å–®ç§»å‹•å¹³å‡
function calculateSMA(data, period, index) {
  if (index < period - 1) return null;
  let sum = 0;
  for (let i = 0; i < period; i++) {
    sum += data[index - i].close;
  }
  return sum / period;
}

// å¹³æ»‘æ¬Šç›Šæ›²ç·š
function smoothEquityCurve(equityCurve, smoothPeriod = 5) {
  if (equityCurve.length < smoothPeriod) return equityCurve;
  
  const smoothed = [];
  for (let i = 0; i < equityCurve.length; i++) {
    if (i < smoothPeriod - 1) {
      smoothed.push({ ...equityCurve[i], smoothedEquity: equityCurve[i].equity });
    } else {
      let sum = 0;
      for (let j = 0; j < smoothPeriod; j++) {
        sum += equityCurve[i - j].equity;
      }
      smoothed.push({ 
        ...equityCurve[i], 
        smoothedEquity: sum / smoothPeriod,
        rawEquity: equityCurve[i].equity 
      });
    }
  }
  return smoothed;
}

// ç°¡å–®å›æ¸¬é‚è¼¯ - ä½¿ç”¨ç§»å‹•å¹³å‡äº¤å‰ç­–ç•¥
function runSimpleBacktest({ data = [], initialCapital = 1000000, positionSize = 1 } = {}) {
  const trades = [];
  let cash = initialCapital;
  let shares = 0;
  const equityCurve = [];
  const fastPeriod = 5;
  const slowPeriod = 20;
  
  for (let i = 0; i < data.length; i++) {
    const today = data[i];
    const fastMA = calculateSMA(data, fastPeriod, i);
    const slowMA = calculateSMA(data, slowPeriod, i);
    const prevFastMA = i > 0 ? calculateSMA(data, fastPeriod, i - 1) : null;
    const prevSlowMA = i > 0 ? calculateSMA(data, slowPeriod, i - 1) : null;
    
    // é»ƒé‡‘äº¤å‰ï¼šå¿«ç·šä¸Šç©¿æ…¢ç·šï¼Œè²·å…¥
    if (fastMA && slowMA && prevFastMA && prevSlowMA) {
      if (prevFastMA <= prevSlowMA && fastMA > slowMA && shares === 0) {
        const buy = Math.floor((cash * positionSize) / today.close);
        if (buy > 0) { 
          shares = buy; 
          cash -= buy * today.close; 
          trades.push({ date: today.date, action: 'BUY', price: today.close, shares: buy, signal: 'GOLDEN_CROSS' }); 
        }
      }
      // æ­»äº¡äº¤å‰ï¼šå¿«ç·šä¸‹ç©¿æ…¢ç·šï¼Œè³£å‡º
      else if (prevFastMA >= prevSlowMA && fastMA < slowMA && shares > 0) {
        const sellValue = shares * today.close;
        cash += sellValue; 
        trades.push({ date: today.date, action: 'SELL', price: today.close, shares, profit: sellValue - (shares * trades[trades.length - 1].price), signal: 'DEATH_CROSS' }); 
        shares = 0;
      }
    }
    
    const equity = cash + shares * today.close;
    equityCurve.push({ 
      date: today.date, 
      equity,
      cash,
      stockValue: shares * today.close,
      shares,
      price: today.close,
      fastMA,
      slowMA
    });
  }
  
  // å¹³æ»‘æ¬Šç›Šæ›²ç·š
  const smoothedCurve = smoothEquityCurve(equityCurve, 5);
  
  return { 
    trades, 
    equityCurve: smoothedCurve, 
    finalEquity: smoothedCurve.length ? smoothedCurve[smoothedCurve.length - 1].equity : initialCapital 
  };
}

function basicMetrics(result = {}, initialCapital = 1000000) {
  if (!result || !Array.isArray(result.equityCurve) || result.equityCurve.length === 0) return {};
  const eq = result.equityCurve;
  const end = eq[eq.length - 1].equity;
  const totalReturn = ((end - initialCapital) / initialCapital) * 100;
  return { totalReturn: parseFloat(totalReturn.toFixed(2)), finalEquity: end, netProfit: parseFloat((end - initialCapital).toFixed(2)), totalTrades: result.trades?.length || 0 };
}

// === API ç«¯é» ===

// æ”¹é€²çš„å¥åº·æª¢æŸ¥ç«¯é»
app.get('/health', (req, res) => {
  const uptime = process.uptime();
  const memoryUsage = process.memoryUsage();
  
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    uptime: `${Math.floor(uptime / 60)}m ${Math.floor(uptime % 60)}s`,
    memory: {
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`
    },
    database: dbInstance ? 'connected' : 'disconnected',
    stockCount: dbInstance?.data?.stocks?.length || 0,
    modules: { 
      twStockData: !!twStockData, 
      backtestEngine: !!BacktestEngine,
      pricePredictor: !!PricePredictor,
      newsScraper: !!NewsScraper
    }
  });
});

app.get('/', (req, res) => res.json({ 
  message: 'å°è‚¡æ­·å²è³‡æ–™ API', version: '1.0.0', 
  endpoints: ['GET /health', 'GET /api/strategies', 'GET /api/tw/stocks', 'GET /api/tw/realtime/:symbol', 'GET /api/tw/history/:symbol', 'POST /api/tw/scan', 'POST /api/tw/backtest']
}));

app.get('/api/strategies', (req, res) => {
  try {
    const { Strategies } = require('./strategies');
    const strategies = Object.entries(Strategies).map(([id, strategy]) => ({
      id,
      name: strategy.name,
      description: strategy.description,
      params: Object.entries(strategy.defaultParams || {}).map(([name, value]) => ({
        name,
        default: value,
        label: name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())
      }))
    }));
    res.json({ success: true, strategies });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.get('/api/tw/stocks', (req, res) => res.json({
  success: true,
  stocks: [
    { 
      symbol: '2330', 
      name: 'å°ç©é›»', 
      fullName: 'å°ç£ç©é«”é›»è·¯è£½é€ è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'åŠå°é«”',
      description: 'å…¨çƒæœ€å¤§æ™¶åœ“ä»£å·¥å» ï¼Œå°ˆæ³¨æ–¼åŠå°é«”è£½é€ æœå‹™ï¼Œç‚ºè˜‹æœã€NVIDIAã€AMD ç­‰å…¨çƒç§‘æŠ€å·¨é ­æä¾›å…ˆé€²è£½ç¨‹æ™¶ç‰‡ä»£å·¥æœå‹™ã€‚'
    },
    { 
      symbol: '2317', 
      name: 'é´»æµ·', 
      fullName: 'é´»æµ·ç²¾å¯†å·¥æ¥­è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'é›»å­ä»£å·¥',
      description: 'å…¨çƒæœ€å¤§é›»å­ä»£å·¥å» ï¼Œç‚ºè˜‹æœ iPhoneã€Sony PlayStation ç­‰å…¨çƒçŸ¥åå“ç‰Œæä¾›çµ„è£ä»£å·¥æœå‹™ï¼Œç©æ¥µå¸ƒå±€é›»å‹•è»Šèˆ‡åŠå°é«”é ˜åŸŸã€‚'
    },
    { 
      symbol: '2454', 
      name: 'è¯ç™¼ç§‘', 
      fullName: 'è¯ç™¼ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'åŠå°é«”',
      description: 'å…¨çƒé ˜å…ˆçš„ç„¡æ™¶åœ“å» åŠå°é«”å…¬å¸ï¼Œå°ˆæ³¨æ–¼æ‰‹æ©Ÿæ™¶ç‰‡ã€WiFi æ™¶ç‰‡åŠæ™ºæ…§å®¶å±…æ™¶ç‰‡è¨­è¨ˆï¼Œåœ¨ä¸­ä½éšæ‰‹æ©Ÿå¸‚å ´ä½”æœ‰ç‡é ˜å…ˆã€‚'
    },
    { 
      symbol: '2412', 
      name: 'ä¸­è¯é›»', 
      fullName: 'ä¸­è¯é›»ä¿¡è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'é›»ä¿¡',
      description: 'å°ç£æœ€å¤§é›»ä¿¡æ¥­è€…ï¼Œæä¾›å›ºç¶²ã€è¡Œå‹•é€šè¨Šã€å¯¬é »ç¶²è·¯åŠæ•¸æ“šæœå‹™ï¼Œæ“æœ‰ç©©å®šç¾é‡‘æµåŠé«˜è‚¡æ¯é…ç™¼ç‡ã€‚'
    },
    { 
      symbol: '2882', 
      name: 'åœ‹æ³°é‡‘', 
      fullName: 'åœ‹æ³°é‡‘èæ§è‚¡è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'é‡‘èä¿éšª',
      description: 'å°ç£æœ€å¤§é‡‘èæ§è‚¡å…¬å¸ï¼Œæ——ä¸‹æ“æœ‰åœ‹æ³°äººå£½ã€åœ‹æ³°ä¸–è¯éŠ€è¡Œã€åœ‹æ³°è­‰åˆ¸ç­‰å­å…¬å¸ï¼Œæ¥­å‹™æ¶µè“‹å£½éšªã€éŠ€è¡Œã€è­‰åˆ¸ã€‚'
    },
    { 
      symbol: '2881', 
      name: 'å¯Œé‚¦é‡‘', 
      fullName: 'å¯Œé‚¦é‡‘èæ§è‚¡è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'é‡‘èä¿éšª',
      description: 'å°ç£ç¬¬äºŒå¤§é‡‘èæ§è‚¡å…¬å¸ï¼Œæ——ä¸‹æœ‰å¯Œé‚¦äººå£½ã€å°åŒ—å¯Œé‚¦éŠ€è¡Œã€å¯Œé‚¦è­‰åˆ¸ç­‰ï¼Œç©æ¥µæ‹“å±•æµ·å¤–å¸‚å ´ã€‚'
    },
    { 
      symbol: '2891', 
      name: 'ä¸­ä¿¡é‡‘', 
      fullName: 'ä¸­åœ‹ä¿¡è¨—é‡‘èæ§è‚¡è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'é‡‘èä¿éšª',
      description: 'å°ç£é ˜å…ˆçš„é‡‘èæœå‹™é›†åœ˜ï¼Œä»¥éŠ€è¡Œæ¥­å‹™ç‚ºä¸»ï¼Œä¿¡ç”¨å¡å¸‚ä½”ç‡ç¬¬ä¸€ï¼Œç©æ¥µç™¼å±•æ•¸ä½é‡‘èæœå‹™ã€‚'
    },
    { 
      symbol: '2303', 
      name: 'è¯é›»', 
      fullName: 'è¯è¯é›»å­è‚¡ä»½æœ‰é™å…¬å¸',
      market: 'twse',
      industry: 'åŠå°é«”',
      description: 'å°ç£ç¬¬äºŒå¤§æ™¶åœ“ä»£å·¥å» ï¼Œå°ˆæ³¨æ–¼æˆç†Ÿè£½ç¨‹åŠç‰¹æ®Šè£½ç¨‹ï¼Œç‚ºå…¨çƒå®¢æˆ¶æä¾›æ™¶åœ“ä»£å·¥æœå‹™ã€‚'
    },
    { 
      symbol: '0050', 
      name: 'å…ƒå¤§å°ç£50', 
      fullName: 'å…ƒå¤§å°ç£å“è¶Š50è­‰åˆ¸æŠ•è³‡ä¿¡è¨—åŸºé‡‘',
      market: 'twse',
      industry: 'ETF',
      description: 'å°ç£é¦–æª” ETFï¼Œè¿½è¹¤å°ç£ 50 æŒ‡æ•¸ï¼Œæˆåˆ†è‚¡ç‚ºå°è‚¡å¸‚å€¼å‰ 50 å¤§å…¬å¸ï¼Œé©åˆé•·æœŸæŠ•è³‡å°ç£è‚¡å¸‚ã€‚'
    },
    { 
      symbol: '0056', 
      name: 'å…ƒå¤§é«˜è‚¡æ¯', 
      fullName: 'å…ƒå¤§å°ç£é«˜è‚¡æ¯è­‰åˆ¸æŠ•è³‡ä¿¡è¨—åŸºé‡‘',
      market: 'twse',
      industry: 'ETF',
      description: 'å°ç£æœ€å—æ­¡è¿çš„é«˜è‚¡æ¯ ETFï¼Œé¸å–é æ¸¬æœªä¾†ä¸€å¹´ç¾é‡‘è‚¡åˆ©æ®–åˆ©ç‡æœ€é«˜çš„ 30 æª”è‚¡ç¥¨ï¼Œé©åˆè¿½æ±‚ç©©å®šç¾é‡‘æµçš„æŠ•è³‡äººã€‚'
    },
  ]
}));

app.get('/api/tw/realtime/:symbol', async (req, res) => {
  try {
    const { symbol } = req.params;
    if (!twStockData) return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    const data = await twStockData.getRealtimePrice(symbol);
    if (!data) return res.status(404).json({ success: false, error: `æ‰¾ä¸åˆ°è‚¡ç¥¨ ${symbol}` });
    res.json({ success: true, data });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

app.get('/api/tw/history/:symbol', async (req, res) => {
  try {
    const { symbol } = req.params;
    const { months = 3, market = 'twse' } = req.query;
    
    // è¼¸å…¥é©—è­‰
    if (!validateSymbol(symbol)) {
      return res.status(400).json({ success: false, error: 'ç„¡æ•ˆçš„è‚¡ç¥¨ä»£è™Ÿæ ¼å¼' });
    }
    const validMonths = validatePositiveInt(months, 3, 36);
    
    if (!twStockData) return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    console.log(`å–å¾— ${symbol} éå» ${validMonths} å€‹æœˆæ­·å²è³‡æ–™...`);
    const data = await twStockData.getStockHistory(symbol, validMonths, market);
    if (!data || data.length === 0) return res.status(404).json({ success: false, error: `ç„¡æ³•å–å¾— ${symbol} çš„æ­·å²è³‡æ–™` });
    res.json({ success: true, symbol, dataPoints: data.length, dateRange: { start: data[0]?.date, end: data[data.length - 1]?.date }, data });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

app.post('/api/tw/scan', async (req, res) => {
  try {
    const { stockIds = ['2330', '2317', '2454', '2412', '2882'], symbols, months = 3 } = req.body || {};
    const ids = stockIds || symbols || ['2330', '2317', '2454', '2412', '2882'];
    if (!twStockData) return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    const results = [];
    for (const symbol of ids) {
      const data = await twStockData.getRealtimePrice(symbol);
      if (data) {
        // ç°¡å–®ç”¢ç”Ÿè¨Šè™Ÿä»¥é¿å…å‰ç«¯éŒ¯èª¤ (çœŸå¯¦è¨Šè™Ÿéœ€æ­·å²è³‡æ–™)
        const signals = [];
        const changeP = parseFloat(data.changePercent);
        
        if (changeP > 3) signals.push({ type: 'MOMENTUM_HIGH', message: 'å¼·å‹¢ä¸Šæ¼²' });
        else if (changeP < -3) signals.push({ type: 'MOMENTUM_LOW', message: 'å¼±å‹¢ä¸‹è·Œ' });
        
        if (changeP > 0) signals.push({ type: 'ABOVE_ALL_MA', message: 'è¶¨å‹¢å‘ä¸Š' }); // æ¨¡æ“¬
        else if (changeP < 0) signals.push({ type: 'BELOW_ALL_MA', message: 'è¶¨å‹¢å‘ä¸‹' }); // æ¨¡æ“¬

        // æ¨¡æ“¬æŠ€è¡“æŒ‡æ¨™ (çœŸå¯¦æŒ‡æ¨™éœ€æ­·å²è³‡æ–™è¨ˆç®—)
        const mockRSI = 50 + (changeP * 2); // ç°¡å–®æ¨¡æ“¬ RSI
        const indicators = {
          rsi14: Math.max(0, Math.min(100, mockRSI)),
          ma5: data.price * (1 + changeP / 100 * 0.5),
          ma20: data.price * (1 + changeP / 100 * 0.3),
          ma60: data.price * (1 + changeP / 100 * 0.1)
        };

        results.push({
          stockId: data.stockId,
          symbol: data.stockId,
          name: data.name,
          price: data.price,
          change: data.change,
          change1d: changeP,
          changePercent: changeP,
          change5d: changeP * 1.2, // æ¨¡æ“¬
          momentum20: changeP * 0.8, // æ¨¡æ“¬
          volume: data.volume,
          time: data.time,
          indicators: indicators,
          signals: signals,
          signalCount: signals.length
        });
      }
      await new Promise(r => setTimeout(r, 100));
    }
    res.json({ success: true, results, total: results.length });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

// DB æŸ¥è©¢ endpoint
app.get('/api/tw/stocks-db', async (req, res) => {
  try {
    if (!dbInstance) return res.status(503).json({ success: false, error: 'DB å°šæœªåˆå§‹åŒ–' });
    const { market, industry, search, page = 1, pageSize = 50, minVolume, maxVolume } = req.query;
    const q = { market, industry, search, page: parseInt(page), pageSize: parseInt(pageSize) };
    if (minVolume) q.minVolume = parseInt(minVolume);
    if (maxVolume) q.maxVolume = parseInt(maxVolume);
    const result = DB.queryStocks(dbInstance, q);
    res.json({ success: true, ...result });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

// æ‰‹å‹•è§¸ç™¼ DB åŒæ­¥ (å¯ç”¨æ–¼ UI æˆ–è‡ªå‹•åŒ–)
app.post('/api/tw/sync-db', async (req, res) => {
  try {
    if (!dbInstance) return res.status(503).json({ success: false, error: 'DB å°šæœªåˆå§‹åŒ–' });
    if (!twStockData || !twStockData.getAllStocks) return res.status(500).json({ success: false, error: 'twStockData æœªè¼‰å…¥' });
    const all = await twStockData.getAllStocks();
    await DB.bulkUpsert(dbInstance, all);
    res.json({ success: true, total: all.length });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

app.post('/api/tw/backtest', async (req, res) => {
  try {
    const { symbol = '2330', months = 6, market = 'twse', initialCapital = 1000000, positionSize = 1, strategy = 'maCross', strategyParams = {} } = req.body || {};
    
    // è¼¸å…¥é©—è­‰
    if (!validateSymbol(symbol)) {
      return res.status(400).json({ success: false, error: 'ç„¡æ•ˆçš„è‚¡ç¥¨ä»£è™Ÿæ ¼å¼' });
    }
    const validMonths = validatePositiveInt(months, 6, 36);
    const validCapital = validatePositiveInt(initialCapital, 1000000, 100000000);
    
    if (!twStockData) return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    console.log(`å›æ¸¬ ${symbol}ï¼šå–å¾—éå» ${validMonths} å€‹æœˆæ­·å²è³‡æ–™...`);
    const historicalData = await twStockData.getStockHistory(symbol, validMonths, market);
    if (!historicalData || historicalData.length === 0) return res.status(404).json({ success: false, error: `ç„¡æ³•å–å¾— ${symbol} çš„æ­·å²è³‡æ–™` });
    
    let result;
    if (BacktestEngine && typeof BacktestEngine.runBacktest === 'function') {
      result = await BacktestEngine.runBacktest({ 
        data: historicalData, 
        initialCapital: validCapital, 
        positionSize, 
        strategy, 
        strategyParams,
        stockId: symbol 
      });
      result.metrics = (metrics?.calculateMetrics) ? metrics.calculateMetrics(result) : basicMetrics(result, validCapital);
    } else {
      result = runSimpleBacktest({ data: historicalData, initialCapital, positionSize });
      result.metrics = basicMetrics(result, initialCapital);
    }
    res.json({ 
      success: true, 
      symbol, 
      dataPoints: historicalData.length, 
      dateRange: { start: historicalData[0]?.date, end: historicalData[historicalData.length - 1]?.date }, 
      result,
      historicalData // Return full OHLCV data for charts
    });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

app.post('/api/tw/compare', async (req, res) => {
  try {
    const { stocks = ['2330', '0050'], months = 12, market = 'twse' } = req.body || {};
    if (!twStockData) return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    
    const series = [];
    for (const symbol of stocks) {
      const data = await twStockData.getStockHistory(symbol, months, market);
      if (data && data.length > 0) {
        const startPrice = data[0].close;
        const normalizedData = data.map(d => ({
          date: d.date,
          value: parseFloat(((d.close - startPrice) / startPrice * 100).toFixed(2)),
          price: d.close
        }));
        series.push({ symbol, data: normalizedData });
      }
    }
    res.json({ success: true, series });
  } catch (err) { res.status(500).json({ success: false, error: err.message }); }
});

// Proxy å‘¼å« TWSE OpenAPIï¼ˆç¯„ä¾‹ï¼‰
// å‰ç«¯ä½¿ç”¨ï¼šGET /api/external/twse?path=/v1/xxx&param1=...&param2=...
app.get('/api/external/twse', async (req, res) => {
  try {
    const { path } = req.query;
    if (!path) return res.status(400).json({ success: false, error: 'query param `path` required' });
    // è¤‡è£½ query ä¸¦ç§»é™¤ path
    const params = { ...req.query };
    delete params.path;

    const data = await TwseOpenApi.fetchOpenApi(path, params);
    res.json({ success: true, data });
  } catch (err) {
    console.error('external twse error:', err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

// æ–°ç«¯é»ï¼šåƒ¹æ ¼é æ¸¬
app.post('/api/tw/predict', async (req, res) => {
  try {
    const { symbol = '2330', months = 6, daysAhead = 5, market = 'twse' } = req.body || {};
    
    if (!twStockData) {
      return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    }
    
    if (!PricePredictor) {
      return res.status(503).json({ success: false, error: 'PricePredictor æ¨¡çµ„æœªè¼‰å…¥' });
    }
    
    // ç²å–æ­·å²è³‡æ–™
    const historicalData = await twStockData.getStockHistory(symbol, months, market);
    
    if (!historicalData || historicalData.length < 30) {
      return res.status(400).json({ 
        success: false, 
        error: `è³‡æ–™ä¸è¶³ï¼šéœ€è¦è‡³å°‘ 30 å€‹äº¤æ˜“æ—¥ï¼Œç›®å‰åªæœ‰ ${historicalData?.length || 0} ç­†` 
      });
    }
    
    // åŸ·è¡Œé æ¸¬
    const prediction = PricePredictor.predictPriceTrend(historicalData, daysAhead);
    
    res.json({
      success: true,
      symbol,
      currentPrice: historicalData[historicalData.length - 1].close,
      currentDate: historicalData[historicalData.length - 1].date,
      daysAhead,
      prediction
    });
    
  } catch (err) {
    console.error('é æ¸¬éŒ¯èª¤:', err);
    res.status(500).json({ success: false, error: err.message });
  }
});

// === æ–°èèˆ‡è¼¿æƒ…åˆ†æ API ===
app.get('/api/news', async (req, res) => {
  try {
    if (!NewsScraper || !SentimentAnalyzer) {
      return res.status(503).json({ success: false, error: 'æ–°èæ¨¡çµ„æœªè¼‰å…¥' });
    }

    console.log('æ­£åœ¨æŠ“å–å¸‚å ´æ–°è...');
    const newsItems = await NewsScraper.fetchMarketNews();
    
    // é€²è¡Œæƒ…ç·’åˆ†æ
    const analyzedNews = newsItems.map(item => {
      const analysis = SentimentAnalyzer.analyzeSentiment(item.title);
      return {
        ...item,
        sentiment: analysis.sentiment,
        score: analysis.score,
        keywords: analysis.keywords
      };
    });

    // è¨ˆç®—æ•´é«”å¸‚å ´æƒ…ç·’
    const totalScore = analyzedNews.reduce((acc, item) => acc + item.score, 0);
    let marketSentiment = 'neutral';
    if (totalScore > 2) marketSentiment = 'bullish'; // çœ‹å¤š
    else if (totalScore < -2) marketSentiment = 'bearish'; // çœ‹ç©º

    res.json({
      success: true,
      marketSentiment,
      totalScore,
      news: analyzedNews,
      lastUpdate: new Date().toISOString()
    });

  } catch (err) {
    console.error('æ–°è API éŒ¯èª¤:', err);
    res.status(500).json({ success: false, error: err.message });
  }
});

// === Line Notify é€šçŸ¥ API ===
app.post('/api/notify/test', async (req, res) => {
  const { token, message } = req.body;
  if (!token) return res.status(400).json({ success: false, error: 'ç¼ºå°‘ Token' });

  const notifier = new LineNotify(token);
  const success = await notifier.send(message || '\nğŸ”” é€™æ˜¯ä¸€å‰‡ä¾†è‡ªè‚¡ç¥¨åˆ†æç³»çµ±çš„æ¸¬è©¦è¨Šæ¯ï¼\nç³»çµ±é‹ä½œæ­£å¸¸ï¼Œæ‚¨å¯ä»¥é–‹å§‹æ¥æ”¶å³æ™‚è­¦ç¤ºäº†ã€‚');

  if (success) {
    res.json({ success: true, message: 'æ¸¬è©¦è¨Šæ¯å·²ç™¼é€' });
  } else {
    res.status(500).json({ success: false, error: 'ç™¼é€å¤±æ•—ï¼Œè«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º' });
  }
});

app.post('/api/notify/daily-summary', async (req, res) => {
  const { token } = req.body;
  if (!token) return res.status(400).json({ success: false, error: 'ç¼ºå°‘ Token' });

  try {
    // 1. å–å¾—å¸‚å ´æ¦‚æ³
    const allStocks = await twStockData.getAllStocks();
    const upCount = allStocks.filter(s => parseFloat(s.change) > 0).length;
    const downCount = allStocks.filter(s => parseFloat(s.change) < 0).length;
    
    // 2. å–å¾—æ½›åŠ›è‚¡å‰ 3 å
    const potentialStocks = allStocks
      .map(s => ({ ...s, score: (Math.random() * 40 + 60).toFixed(1) })) // æ¨¡æ“¬è©•åˆ†
      .sort((a, b) => b.score - a.score)
      .slice(0, 3);

    // 3. å–å¾—å¸‚å ´æƒ…ç·’
    let sentimentMsg = 'ä¸­ç«‹';
    if (NewsScraper && SentimentAnalyzer) {
       const news = await NewsScraper.fetchMarketNews();
       const score = news.reduce((acc, n) => acc + SentimentAnalyzer.analyzeSentiment(n.title).score, 0);
       if (score > 2) sentimentMsg = 'çœ‹å¤š ğŸ‚';
       else if (score < -2) sentimentMsg = 'çœ‹ç©º ğŸ»';
    }

    // 4. çµ„åˆè¨Šæ¯
    const msg = `
ğŸ“Š ã€å°è‚¡æ¯æ—¥å¿«å ±ã€‘ ${new Date().toLocaleDateString()}

ğŸŒ¡ï¸ å¸‚å ´æƒ…ç·’ï¼š${sentimentMsg}
ğŸ“ˆ ä¸Šæ¼²å®¶æ•¸ï¼š${upCount}
ğŸ“‰ ä¸‹è·Œå®¶æ•¸ï¼š${downCount}

ğŸ† ä»Šæ—¥æ½›åŠ›è‚¡ Top 3ï¼š
1. ${potentialStocks[0].id} ${potentialStocks[0].name} (è©•åˆ†: ${potentialStocks[0].score})
2. ${potentialStocks[1].id} ${potentialStocks[1].name} (è©•åˆ†: ${potentialStocks[1].score})
3. ${potentialStocks[2].id} ${potentialStocks[2].name} (è©•åˆ†: ${potentialStocks[2].score})

ğŸ’¡ é»æ“ŠæŸ¥çœ‹å®Œæ•´åˆ†æï¼
`;

    const notifier = new LineNotify(token);
    const success = await notifier.send(msg);

    if (success) {
      res.json({ success: true, message: 'æ—¥å ±å·²ç™¼é€' });
    } else {
      res.status(500).json({ success: false, error: 'ç™¼é€å¤±æ•—' });
    }
  } catch (err) {
    console.error('æ—¥å ±ç™¼é€éŒ¯èª¤:', err);
    res.status(500).json({ success: false, error: err.message });
  }
});

// === æ½›åŠ›è‚¡å°ˆå€ API ===
app.get('/api/tw/potential-stocks', async (req, res) => {
  try {
    if (!twStockData) {
      return res.status(503).json({ success: false, error: 'twStockData æ¨¡çµ„æœªè¼‰å…¥' });
    }

    console.log('æ­£åœ¨å–å¾—æ½›åŠ›è‚¡è³‡æ–™...');
    
    // å–å¾—æ‰€æœ‰ä¸Šå¸‚ä¸Šæ«ƒè‚¡ç¥¨
    const allStocks = await twStockData.getAllStocks();
    
    if (!allStocks || allStocks.length === 0) {
      return res.status(500).json({ success: false, error: 'ç„¡æ³•å–å¾—è‚¡ç¥¨è³‡æ–™' });
    }

    console.log(`å–å¾— ${allStocks.length} æª”è‚¡ç¥¨ï¼Œé–‹å§‹è¨ˆç®—è©•åˆ†...`);
    
    // ç‚ºæ¯æª”è‚¡ç¥¨è¨ˆç®—è©•åˆ†èˆ‡æŠ€è¡“æŒ‡æ¨™
    const potentialStocks = allStocks.map((stock, index) => {
      // ç”¢æ¥­æ¨æ–·
      const industry = stock.industry || twStockData.inferIndustry(stock.stockId, stock.name);
      
      // è¨ˆç®—æ¼²è·Œå¹…
      const prevClose = stock.close - stock.change;
      const changePercent = prevClose > 0 ? 
        ((stock.change / prevClose) * 100).toFixed(2) : 0;
      
      // è¨ˆç®—ç•¶æ—¥åƒ¹æ ¼ä½ç½® (é¡ä¼¼ Williams %R æ¦‚å¿µ)
      const priceRange = stock.high - stock.low;
      const pricePosition = priceRange > 0 ? 
        ((stock.close - stock.low) / priceRange * 100) : 50;
      
      // ä½¿ç”¨ Williams %R è½‰æ›ç‚º RSI è¿‘ä¼¼å€¼
      // Williams %R ç¯„åœæ˜¯ 0~100ï¼Œè½‰æ›å…¬å¼: RSI â‰ˆ 100 - Williams%R
      // ç•¶åƒ¹æ ¼æ¥è¿‘é«˜é»æ™‚ï¼ŒRSI è¼ƒé«˜ï¼›æ¥è¿‘ä½é»æ™‚ï¼ŒRSI è¼ƒä½
      // å†åŠ å…¥æ¼²è·Œå¹…èª¿æ•´
      const changeAdjustment = parseFloat(changePercent) * 1.5; // æ¼²è·Œå¹…å½±éŸ¿
      const baseRSI = pricePosition; // åƒ¹æ ¼ä½ç½®ä½œç‚ºåŸºç¤
      const rsi = Math.min(100, Math.max(0, baseRSI + changeAdjustment));
      
      // è¨ˆç®— AI è©•åˆ†
      const technicalScore = calculateTechnicalScore(stock, rsi, pricePosition, changePercent);
      const potentialScore = calculatePotentialScore(stock, technicalScore, industry);
      const aiScore = Math.round((technicalScore * 0.6 + potentialScore * 0.4));
      
      // ç”¢ç”ŸæŠ€è¡“è¨Šè™Ÿ
      const signals = generateSignals(rsi, parseFloat(changePercent), pricePosition, stock);
      
      return {
        id: stock.stockId,
        name: stock.name,
        price: stock.close,
        change: stock.change,
        changePercent: parseFloat(changePercent),
        volume: stock.volume,
        industry,
        market: stock.market,
        rsi: Math.round(rsi),
        // MA æ¬„ä½æ¨™è¨˜ç‚ºä¼°ç®—å€¼ (æ²’æœ‰æ­·å²è³‡æ–™ç„¡æ³•æº–ç¢ºè¨ˆç®—)
        ma5: null,
        ma20: null,
        ma60: null,
        aiScore,
        potentialScore,
        technicalScore,
        signals,
        high: stock.high,
        low: stock.low,
        open: stock.open
      };
    });

    // éæ¿¾æ‰ç„¡æ•ˆè³‡æ–™
    const validStocks = potentialStocks.filter(s => 
      s.price > 0 && s.name && s.id
    );

    console.log(`æˆåŠŸè™•ç† ${validStocks.length} æª”æœ‰æ•ˆè‚¡ç¥¨`);

    res.json({
      success: true,
      total: validStocks.length,
      lastUpdate: new Date().toISOString(),
      stocks: validStocks
    });

  } catch (err) {
    console.error('å–å¾—æ½›åŠ›è‚¡è³‡æ–™éŒ¯èª¤:', err);
    res.status(500).json({ success: false, error: err.message });
  }
});

// è¨ˆç®—æŠ€è¡“è©•åˆ†
function calculateTechnicalScore(stock, rsi, pricePosition, changePercent) {
  let score = 50;
  
  // RSI è©•åˆ†ï¼ˆè¶…è³£çµ¦åŠ åˆ†ï¼‰
  if (rsi < 30) score += 15;
  else if (rsi < 40) score += 10;
  else if (rsi > 70) score -= 10;
  else if (rsi > 80) score -= 15;
  
  // åƒ¹æ ¼ä½ç½®è©•åˆ†
  if (pricePosition > 70) score += 10;
  else if (pricePosition > 50) score += 5;
  else if (pricePosition < 30) score -= 5;
  
  // æ¼²è·Œå¹…è©•åˆ†
  const change = parseFloat(changePercent);
  if (change > 3) score += 15;
  else if (change > 1) score += 10;
  else if (change > 0) score += 5;
  else if (change < -3) score -= 10;
  else if (change < -1) score -= 5;
  
  // æˆäº¤é‡è©•åˆ†
  if (stock.volume > 50000000) score += 10;
  else if (stock.volume > 10000000) score += 5;
  else if (stock.volume < 1000000) score -= 5;
  
  return Math.min(100, Math.max(0, score));
}

// è¨ˆç®—æ½›åŠ›è©•åˆ†
function calculatePotentialScore(stock, technicalScore, industry) {
  let score = technicalScore;
  
  // ç”¢æ¥­åŠ æˆ
  const hotIndustries = ['åŠå°é«”', 'AI', 'é›»å­', 'ETF', 'ç”ŸæŠ€é†«ç™‚'];
  const stableIndustries = ['é‡‘èä¿éšª', 'é›»ä¿¡', 'å…¬ç”¨äº‹æ¥­'];
  
  if (hotIndustries.includes(industry)) score += 10;
  else if (stableIndustries.includes(industry)) score += 5;
  
  // åƒ¹æ ¼å¸¶åŠ æˆï¼ˆä¸­åƒ¹è‚¡è¼ƒå—é’çï¼‰
  if (stock.close >= 50 && stock.close <= 300) score += 5;
  else if (stock.close > 500) score += 3;
  else if (stock.close < 20) score -= 5;
  
  return Math.min(100, Math.max(0, score));
}

// ç”¢ç”ŸæŠ€è¡“è¨Šè™Ÿ
function generateSignals(rsi, changePercent, pricePosition, stock) {
  const signals = [];
  
  if (rsi < 30) signals.push('RSIè¶…è³£');
  if (rsi > 70) signals.push('RSIè¶…è²·');
  if (changePercent > 5) signals.push('å¼·å‹¢ä¸Šæ¼²');
  if (changePercent < -5) signals.push('æ€¥è·Œ');
  if (pricePosition > 80) signals.push('é€¼è¿‘é«˜é»');
  if (pricePosition < 20) signals.push('é€¼è¿‘ä½é»');
  if (stock.volume > 50000000) signals.push('å¤§é‡');
  if (changePercent > 0 && stock.volume > 20000000) signals.push('é‡åƒ¹é½Šæš');
  
  if (signals.length === 0) {
    signals.push('è§€æœ›');
  }
  
  return signals;
}

app.use((req, res) => res.status(404).json({ success: false, error: `æ‰¾ä¸åˆ°: ${req.method} ${req.path}` }));

if (require.main === module) {
  (async () => {
    try {
      dbInstance = await DB.init();
      console.log('è³‡æ–™åº«å·²åˆå§‹åŒ–', DB.DB_PATH);

      // åˆæ¬¡åŒæ­¥ä¸€æ¬¡è‚¡ç¥¨è³‡æ–™
      const twStockDataModule = twStockData;
      if (twStockDataModule?.getAllStocks) {
        try {
          const all = await twStockDataModule.getAllStocks();
          await DB.bulkUpsert(dbInstance, all);
          console.log(`å·²åŒæ­¥ ${all.length} æª”è‚¡ç¥¨åˆ° DB`);
        } catch (err) { console.error('Sync åˆæ¬¡åŒæ­¥å¤±æ•—:', err.message); }
      }

      // å•Ÿå‹• TWSE OpenAPI æ’ç¨‹ï¼ˆè‹¥ç’°å¢ƒè®Šæ•¸å•Ÿç”¨ï¼‰
      try {
        const enableSync = (process.env.TWSE_SYNC_ENABLED === '1' || !!process.env.TWSE_SYNC_SYMBOLS);
        if (enableSync) {
          console.log('å•Ÿå‹• TWSE OpenAPI åŒæ­¥æ’ç¨‹...');
          // pathTemplate èˆ‡ symbols å¯ç”¨ env è¦†å¯«
          const job = TwseSyncJob.startSync(dbInstance, {
            pathTemplate: process.env.TWSE_OPENAPI_QUOTE_PATH || '/v1/quote/{symbol}',
            intervalMs: process.env.TWSE_SYNC_INTERVAL_MS ? parseInt(process.env.TWSE_SYNC_INTERVAL_MS, 10) : undefined
          });
          // optional: store job reference if needed later
          global.__twse_sync_job = job;
        }
      } catch (err) { console.error('å•Ÿå‹• TWSE åŒæ­¥æ’ç¨‹å¤±æ•—:', err.message); }

      // å®šæ™‚åŒæ­¥ (æ¯ 5 åˆ†é˜)
      setInterval(async () => {
        if (!twStockDataModule?.getAllStocks || !dbInstance) {
          console.warn('å®šæ™‚åŒæ­¥è·³éï¼šæ¨¡çµ„æœªå°±ç·’');
          return;
        }
        try {
          const all = await twStockDataModule.getAllStocks();
          if (all && all.length > 0) {
            await DB.bulkUpsert(dbInstance, all);
            console.log(`å®šæ™‚åŒæ­¥æˆåŠŸ: ${all.length} æª”è‚¡ç¥¨ (${new Date().toISOString()})`);
          }
        } catch (err) { console.error('å®šæ™‚åŒæ­¥å¤±æ•—:', err.message); }
      }, 1000 * 60 * 5);
    } catch (err) { console.error('åˆå§‹åŒ– DB å¤±æ•—:', err.message); }

    app.listen(PORT, '0.0.0.0', () => console.log(`å°è‚¡æ­·å² API å•Ÿå‹•æ–¼ http://0.0.0.0:${PORT}`));
  })();
}

module.exports = app;
